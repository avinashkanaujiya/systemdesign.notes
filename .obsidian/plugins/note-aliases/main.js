/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => NoteAliases
});
var import_obsidian2 = __toModule(require("obsidian"));

// src/Settings.ts
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  debugMode: false
};
var lastPlugin = { settings: DEFAULT_SETTINGS };
var NoteAliasesSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    lastPlugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Debug Mode").setDesc("To display or not console debug messages").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.debugMode = value;
      yield this.plugin.saveSettings();
    })));
  }
};
function getSettings() {
  return lastPlugin.settings;
}

// src/util/log.ts
function log(...args) {
  if (!getSettings().debugMode)
    return;
  console.log(...args);
}

// src/util/markdownLinksHelper.ts
function getLinks(text) {
  return getWikilinks(text).concat(getMdlinks(text));
}
function getWikilinks(text) {
  const linkRe = /\[\[(?<target>[^[|#]*)(?:#(?<anchor>[^[|]*))?\|(?<alias>[^\]]*)\]\]/gu;
  const found = [];
  for (const match of text.matchAll(linkRe)) {
    found.push(getLinkFromMatch(match, text));
  }
  return found;
}
function getMdlinks(text) {
  const linkBrRe = /\[(?<alias>(?:[^\]\\]|\\\]|\\[^\]])*)\]\(<(?<target>[^#>"]*)(?:#(?<anchor>[^>"]*))?(?: "(?<title>[^>]*)")?>\)/gu;
  const linkRe = /\[(?<alias>(?:[^\]\\]|\\\]|\\[^\]])*)\]\((?<target>[^ #\)]*)(?:#(?<anchor>[^\) ]*))?(?: "(?<title>[^>]*)")?\)/gu;
  const found = [];
  for (const match of text.matchAll(linkRe)) {
    found.push(getLinkFromMatch(match, text));
  }
  for (const match of text.matchAll(linkBrRe)) {
    found.push(getLinkFromMatch(match, text));
  }
  return found;
}
function getLinkFromMatch(match, text) {
  const start = match.index || 0;
  const end = start + match[0].length;
  const { target, anchor, alias, title } = match.groups;
  return { target, anchor, alias, title, start, end };
}

// main.ts
var NoteAliases = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.notice = null;
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = __spreadValues(__spreadValues({}, DEFAULT_SETTINGS), yield this.loadData());
    });
  }
  onload() {
    return __async(this, null, function* () {
      this.addSettingTab(new NoteAliasesSettingTab(this.app, this));
      yield this.loadSettings();
      this.addCommands();
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  addCommands() {
    this.addCommand({
      id: "save-alias",
      name: "Save alias of the link under cursor in the target note frontmatter",
      editorCheckCallback: (checking, editor, view) => {
        const position = editor.getCursor();
        const line = editor.getLine(position.line);
        const links = getLinks(line);
        const link = links.find((linkItem) => linkItem.start <= position.ch && linkItem.end >= position.ch);
        if (!link)
          return false;
        if (checking)
          return true;
        this.saveAlias(view, link).catch((error) => {
          console.error(error);
        });
        return true;
      }
    });
  }
  getTargetFile(target, fromPath) {
    return __async(this, null, function* () {
      const existFile = this.app.metadataCache.getFirstLinkpathDest(target, fromPath);
      if (existFile)
        return existFile;
      const targetPath = `${this.app.fileManager.getNewFileParent(fromPath).path}/${target}.md`;
      const targetFile = yield this.app.vault.create(targetPath, "");
      return targetFile;
    });
  }
  processFrontMatter(file, fn) {
    return __async(this, null, function* () {
      var _a;
      if (typeof this.app.fileManager.processFrontMatter === "function") {
        yield this.app.fileManager.processFrontMatter(file, fn);
        return;
      }
      const frontMatterRe = /^---+\n(?<frontmatter>(?:.|\n)*)---+$/um;
      const contentBefore = yield this.app.vault.read(file);
      const frontmatterStr = (_a = frontMatterRe.exec(contentBefore)) == null ? void 0 : _a[1];
      const frontmatter = frontmatterStr ? (0, import_obsidian2.parseYaml)(frontmatterStr) : {};
      fn(frontmatter);
      const processedFrontMatter = `---
${(0, import_obsidian2.stringifyYaml)(frontmatter)}---`;
      const contentAfter = frontmatterStr ? contentBefore.replace(frontMatterRe, processedFrontMatter) : `${processedFrontMatter}
${contentBefore}`;
      yield this.app.vault.modify(file, contentAfter);
    });
  }
  saveAlias(view, link) {
    return __async(this, null, function* () {
      const { alias } = link;
      if (!alias)
        return;
      const fromPath = view.file.path;
      const targetFile = yield this.getTargetFile(link.target, fromPath);
      log("saveAlias", { link, sourceFile: fromPath, targetFile });
      if (targetFile.extension !== "md")
        return;
      yield this.processFrontMatter(targetFile, (metadata) => {
        var _a;
        const aliases = (_a = (0, import_obsidian2.parseFrontMatterAliases)(metadata)) != null ? _a : [];
        const exists = aliases.some((item) => item === alias);
        if (exists) {
          this.notify(`save-alias: "${alias}" already in aliases list of "${targetFile.basename}"`);
          return;
        }
        metadata.aliases = [...aliases, alias];
        this.notify(`save-alias: "${alias}" saved in "${targetFile.basename}"`);
      });
    });
  }
  notify(message) {
    var _a;
    (_a = this.notice) == null ? void 0 : _a.hide();
    this.notice = new import_obsidian2.Notice(message);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzcmMvU2V0dGluZ3MudHMiLCAic3JjL3V0aWwvbG9nLnRzIiwgInNyYy91dGlsL21hcmtkb3duTGlua3NIZWxwZXIudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vIGh0dHBzOi8vbWFyY3VzLnNlLm5ldC9vYnNpZGlhbi1wbHVnaW4tZG9jcy9yZWZlcmVuY2UvdHlwZXNjcmlwdFxuaW1wb3J0IHsgTm90aWNlLCBQbHVnaW4sIHBhcnNlRnJvbnRNYXR0ZXJBbGlhc2VzLCBwYXJzZVlhbWwsIHN0cmluZ2lmeVlhbWwgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgdHlwZSB7IEVkaXRvciwgTWFya2Rvd25WaWV3LCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcblxuaW1wb3J0IHR5cGUgeyBOb3RlQWxpYXNlc1NldHRpbmdzIH0gZnJvbSAnLi9zcmMvU2V0dGluZ3MnO1xuaW1wb3J0IE5vdGVBbGlhc2VzU2V0dGluZ1RhYiwgeyBERUZBVUxUX1NFVFRJTkdTIH0gZnJvbSAnLi9zcmMvU2V0dGluZ3MnO1xuaW1wb3J0IHsgZ2V0TGlua3MsIGxvZyB9IGZyb20gJy4vc3JjL3V0aWwnO1xuaW1wb3J0IHR5cGUgeyBMaW5rIH0gZnJvbSAnLi9zcmMvdXRpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vdGVBbGlhc2VzIGV4dGVuZHMgUGx1Z2luIHtcbiAgcHVibGljIHNldHRpbmdzOiBOb3RlQWxpYXNlc1NldHRpbmdzID0gREVGQVVMVF9TRVRUSU5HUztcblxuICBwcml2YXRlIG5vdGljZTogTm90aWNlIHwgbnVsbCA9IG51bGw7XG5cbiAgcHVibGljIGFzeW5jIGxvYWRTZXR0aW5ncyAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHsgLi4uREVGQVVMVF9TRVRUSU5HUywgLi4uKGF3YWl0IHRoaXMubG9hZERhdGEoKSkgYXMgTm90ZUFsaWFzZXNTZXR0aW5ncyB9O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIG9ubG9hZCAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBOb3RlQWxpYXNlc1NldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcbiAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzYXZlU2V0dGluZ3MgKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gIH1cblxuICBwcml2YXRlIGFkZENvbW1hbmRzICgpOiB2b2lkIHtcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6ICdzYXZlLWFsaWFzJyxcbiAgICAgIG5hbWU6ICdTYXZlIGFsaWFzIG9mIHRoZSBsaW5rIHVuZGVyIGN1cnNvciBpbiB0aGUgdGFyZ2V0IG5vdGUgZnJvbnRtYXR0ZXInLFxuXG4gICAgICBlZGl0b3JDaGVja0NhbGxiYWNrOiAoY2hlY2tpbmc6IGJvb2xlYW4sIGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShwb3NpdGlvbi5saW5lKTtcbiAgICAgICAgY29uc3QgbGlua3MgPSBnZXRMaW5rcyhsaW5lKTtcbiAgICAgICAgY29uc3QgbGluayA9IGxpbmtzLmZpbmQoXG4gICAgICAgICAgbGlua0l0ZW0gPT4gbGlua0l0ZW0uc3RhcnQgPD0gcG9zaXRpb24uY2ggJiYgbGlua0l0ZW0uZW5kID49IHBvc2l0aW9uLmNoXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFsaW5rKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjaGVja2luZykgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgdGhpcy5zYXZlQWxpYXModmlldywgbGluaykuY2F0Y2goZXJyb3IgPT4geyBjb25zb2xlLmVycm9yKGVycm9yKTsgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0VGFyZ2V0RmlsZSAodGFyZ2V0OiBzdHJpbmcsIGZyb21QYXRoOiBzdHJpbmcpOiBQcm9taXNlPFRGaWxlPiB7XG4gICAgY29uc3QgZXhpc3RGaWxlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdCh0YXJnZXQsIGZyb21QYXRoKTtcbiAgICBpZiAoZXhpc3RGaWxlKSByZXR1cm4gZXhpc3RGaWxlO1xuXG4gICAgY29uc3QgdGFyZ2V0UGF0aCA9IGAke3RoaXMuYXBwLmZpbGVNYW5hZ2VyLmdldE5ld0ZpbGVQYXJlbnQoZnJvbVBhdGgpLnBhdGh9LyR7dGFyZ2V0fS5tZGA7XG4gICAgY29uc3QgdGFyZ2V0RmlsZSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZSh0YXJnZXRQYXRoLCAnJyk7XG4gICAgcmV0dXJuIHRhcmdldEZpbGU7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHByb2Nlc3NGcm9udE1hdHRlciAoXG4gICAgZmlsZTogVEZpbGUsIGZuOiAoZnJvbnRtYXR0ZXI6IG9iamVjdCkgPT4gdm9pZFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodHlwZW9mIHRoaXMuYXBwLmZpbGVNYW5hZ2VyLnByb2Nlc3NGcm9udE1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXdhaXQgdGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKGZpbGUsIGZuKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBmcm9udE1hdHRlclJlID0gL14tLS0rXFxuKD88ZnJvbnRtYXR0ZXI+KD86LnxcXG4pKiktLS0rJC91bTtcbiAgICBjb25zdCBjb250ZW50QmVmb3JlID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChmaWxlKTtcbiAgICBjb25zdCBmcm9udG1hdHRlclN0ciA9IGZyb250TWF0dGVyUmUuZXhlYyhjb250ZW50QmVmb3JlKT8uWzFdO1xuICAgIGNvbnN0IGZyb250bWF0dGVyID0gKGZyb250bWF0dGVyU3RyID8gcGFyc2VZYW1sKGZyb250bWF0dGVyU3RyKSA6IHt9KSBhcyBvYmplY3Q7XG5cbiAgICBmbihmcm9udG1hdHRlcik7XG5cbiAgICBjb25zdCBwcm9jZXNzZWRGcm9udE1hdHRlciA9IGAtLS1cXG4ke3N0cmluZ2lmeVlhbWwoZnJvbnRtYXR0ZXIpfS0tLWA7XG4gICAgY29uc3QgY29udGVudEFmdGVyID0gZnJvbnRtYXR0ZXJTdHIgP1xuICAgICAgY29udGVudEJlZm9yZS5yZXBsYWNlKGZyb250TWF0dGVyUmUsIHByb2Nlc3NlZEZyb250TWF0dGVyKSA6XG4gICAgICBgJHtwcm9jZXNzZWRGcm9udE1hdHRlcn1cXG4ke2NvbnRlbnRCZWZvcmV9YDtcblxuICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShmaWxlLCBjb250ZW50QWZ0ZXIpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzYXZlQWxpYXMgKHZpZXc6IE1hcmtkb3duVmlldywgbGluazogTGluayk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHsgYWxpYXMgfSA9IGxpbms7XG4gICAgaWYgKCFhbGlhcykgcmV0dXJuO1xuXG4gICAgY29uc3QgZnJvbVBhdGggPSB2aWV3LmZpbGUucGF0aDtcbiAgICBjb25zdCB0YXJnZXRGaWxlID0gYXdhaXQgdGhpcy5nZXRUYXJnZXRGaWxlKGxpbmsudGFyZ2V0LCBmcm9tUGF0aCk7XG5cbiAgICBsb2coJ3NhdmVBbGlhcycsIHsgbGluaywgc291cmNlRmlsZTogZnJvbVBhdGgsIHRhcmdldEZpbGUgfSk7XG4gICAgaWYgKHRhcmdldEZpbGUuZXh0ZW5zaW9uICE9PSAnbWQnKSByZXR1cm47XG5cbiAgICBhd2FpdCB0aGlzLnByb2Nlc3NGcm9udE1hdHRlcih0YXJnZXRGaWxlLCAobWV0YWRhdGE6IHsgYWxpYXNlcz86IHVua25vd24gfSkgPT4ge1xuICAgICAgY29uc3QgYWxpYXNlcyA9IHBhcnNlRnJvbnRNYXR0ZXJBbGlhc2VzKG1ldGFkYXRhKSA/PyBbXTtcbiAgICAgIGNvbnN0IGV4aXN0cyA9IGFsaWFzZXMuc29tZShpdGVtID0+IGl0ZW0gPT09IGFsaWFzKTtcblxuICAgICAgaWYgKGV4aXN0cykge1xuICAgICAgICB0aGlzLm5vdGlmeShgc2F2ZS1hbGlhczogXCIke2FsaWFzfVwiIGFscmVhZHkgaW4gYWxpYXNlcyBsaXN0IG9mIFwiJHt0YXJnZXRGaWxlLmJhc2VuYW1lfVwiYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWV0YWRhdGEuYWxpYXNlcyA9IFsuLi5hbGlhc2VzLCBhbGlhc107XG4gICAgICB0aGlzLm5vdGlmeShgc2F2ZS1hbGlhczogXCIke2FsaWFzfVwiIHNhdmVkIGluIFwiJHt0YXJnZXRGaWxlLmJhc2VuYW1lfVwiYCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG5vdGlmeSAobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5ub3RpY2U/LmhpZGUoKTtcbiAgICB0aGlzLm5vdGljZSA9IG5ldyBOb3RpY2UobWVzc2FnZSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSBOb3RlQWxpYXNlcyBmcm9tICcuLi9tYWluJztcbmltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcblxuZXhwb3J0IGludGVyZmFjZSBOb3RlQWxpYXNlc1NldHRpbmdzIHtcbiAgZGVidWdNb2RlOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogTm90ZUFsaWFzZXNTZXR0aW5ncyA9IHtcbiAgZGVidWdNb2RlOiBmYWxzZSxcbn07XG5cbmxldCBsYXN0UGx1Z2luID0geyBzZXR0aW5nczogREVGQVVMVF9TRVRUSU5HUyB9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb3RlQWxpYXNlc1NldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgcGx1Z2luOiBOb3RlQWxpYXNlcztcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBOb3RlQWxpYXNlcykge1xuICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICBsYXN0UGx1Z2luID0gcGx1Z2luO1xuICB9XG5cbiAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICBsZXQgeyBjb250YWluZXJFbCB9ID0gdGhpcztcblxuICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiRGVidWcgTW9kZVwiKVxuICAgICAgLnNldERlc2MoXCJUbyBkaXNwbGF5IG9yIG5vdCBjb25zb2xlIGRlYnVnIG1lc3NhZ2VzXCIpXG4gICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+IHRvZ2dsZVxuICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVidWdNb2RlKVxuICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVidWdNb2RlID0gdmFsdWU7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXR0aW5ncyAoKTogTm90ZUFsaWFzZXNTZXR0aW5ncyB7XG4gIHJldHVybiBsYXN0UGx1Z2luLnNldHRpbmdzO1xufVxuIiwgImltcG9ydCB7IGdldFNldHRpbmdzIH0gZnJvbSAnLi4vU2V0dGluZ3MnO1xuXG5leHBvcnQgZnVuY3Rpb24gbG9nICguLi5hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcbiAgaWYgKCFnZXRTZXR0aW5ncygpLmRlYnVnTW9kZSkgcmV0dXJuO1xuICBjb25zb2xlLmxvZyguLi5hcmdzKTtcbn1cbiIsICJleHBvcnQgaW50ZXJmYWNlIExpbmsge1xuICAvKiogVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBsaW5rIHRleHQgaW4gdGhlIHRleHQgKi9cbiAgc3RhcnQ6IG51bWJlcjtcbiAgLyoqIFRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIGxpbmsgdGV4dCBpbiB0aGUgdGV4dCAqL1xuICBlbmQ6IG51bWJlcjtcbiAgLyoqIFRoZSB0YXJnZXQgc3RyaW5nIGluIHRoZSBwYXJzZWQgbGluayAqL1xuICB0YXJnZXQ6IHN0cmluZztcbiAgLyoqIFRoZSBhbmNob3Igc3RyaW5nIGluIHRoZSBwYXJzZWQgbGluayAqL1xuICBhbmNob3I6IHN0cmluZztcbiAgLyoqIFRoZSBhbGlhcyBzdHJpbmcgaW4gdGhlIHBhcnNlZCBsaW5rICovXG4gIGFsaWFzPzogc3RyaW5nO1xuICAvKiogVGhlIHRpdGxlIHN0cmluZyBpbiB0aGUgcGFyc2VkIGxpbmsgKi9cbiAgdGl0bGU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMaW5rcyAodGV4dDogc3RyaW5nKTogTGlua1tdIHtcbiAgcmV0dXJuIGdldFdpa2lsaW5rcyh0ZXh0KS5jb25jYXQoZ2V0TWRsaW5rcyh0ZXh0KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRXaWtpbGlua3MgKHRleHQ6IHN0cmluZyk6IExpbmtbXSB7XG4gIGNvbnN0IGxpbmtSZSA9IC9cXFtcXFsoPzx0YXJnZXQ+W15bfCNdKikoPzojKD88YW5jaG9yPlteW3xdKikpP1xcfCg/PGFsaWFzPlteXFxdXSopXFxdXFxdL2d1O1xuICBjb25zdCBmb3VuZDogTGlua1tdID0gW107XG4gIGZvciAoY29uc3QgbWF0Y2ggb2YgdGV4dC5tYXRjaEFsbChsaW5rUmUpKSB7XG4gICAgZm91bmQucHVzaChnZXRMaW5rRnJvbU1hdGNoKG1hdGNoLCB0ZXh0KSk7XG4gIH1cbiAgcmV0dXJuIGZvdW5kO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWRsaW5rcyAodGV4dDogc3RyaW5nKTogTGlua1tdIHtcbiAgY29uc3QgbGlua0JyUmUgPSAvXFxbKD88YWxpYXM+KD86W15cXF1cXFxcXXxcXFxcXFxdfFxcXFxbXlxcXV0pKilcXF1cXCg8KD88dGFyZ2V0PlteIz5cIl0qKSg/OiMoPzxhbmNob3I+W14+XCJdKikpPyg/OiBcIig/PHRpdGxlPltePl0qKVwiKT8+XFwpL2d1O1xuICBjb25zdCBsaW5rUmUgPSAvXFxbKD88YWxpYXM+KD86W15cXF1cXFxcXXxcXFxcXFxdfFxcXFxbXlxcXV0pKilcXF1cXCgoPzx0YXJnZXQ+W14gI1xcKV0qKSg/OiMoPzxhbmNob3I+W15cXCkgXSopKT8oPzogXCIoPzx0aXRsZT5bXj5dKilcIik/XFwpL2d1O1xuICBjb25zdCBmb3VuZDogTGlua1tdID0gW107XG4gIGZvciAoY29uc3QgbWF0Y2ggb2YgdGV4dC5tYXRjaEFsbChsaW5rUmUpKSB7XG4gICAgZm91bmQucHVzaChnZXRMaW5rRnJvbU1hdGNoKG1hdGNoLCB0ZXh0KSk7XG4gIH1cbiAgZm9yIChjb25zdCBtYXRjaCBvZiB0ZXh0Lm1hdGNoQWxsKGxpbmtCclJlKSkge1xuICAgIGZvdW5kLnB1c2goZ2V0TGlua0Zyb21NYXRjaChtYXRjaCwgdGV4dCkpO1xuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cblxuICBmdW5jdGlvbiBnZXRMaW5rRnJvbU1hdGNoIChtYXRjaDogUmVnRXhwTWF0Y2hBcnJheSwgdGV4dDogc3RyaW5nKTogTGluayB7XG4gICAgY29uc3Qgc3RhcnQgPSBtYXRjaC5pbmRleCB8fCAwO1xuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIGNvbnN0IHsgdGFyZ2V0LCBhbmNob3IsIGFsaWFzLCB0aXRsZSB9ID0gbWF0Y2guZ3JvdXBzITtcbiAgICByZXR1cm4geyB0YXJnZXQsIGFuY2hvciwgYWxpYXMsIHRpdGxlLCBzdGFydCwgZW5kIH07XG4gIH1cbiJdLAogICJt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
